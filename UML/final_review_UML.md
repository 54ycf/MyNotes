# 公共机制

* 公共机制Common Mechanism包括四类

  * **修饰** adornments,

    * 注释（Note）：折角矩形，可以用作任何UML元素，虚线连接，可以注解多个元素
    * 可见性、角色、多重性等，常见于（但不限于）**关联**中的说明

  *  **扩充机制** extensibility mechanisms

    * 构造型（衍型，stereotype)：特定的问题领域具有特殊含义的新的建模元素

    * 标记值(tagged value)：需要增加一个新的构成以表达建模元素的某种特性，就可以使用标记值。标记值的放置，没有限制，不要引起误解。标记值字符串用花括弧括( {} )起来，放置到原建模元素的名字的下方

      {author=Joe, status=tested, requirement=3.563}

    * 约束（constraint)：此文本串被括在一对花括号内，并被放置在被约束的建模元素附近

      { speed > 100M } 

  * 规格说明 specifications

  * 公用划分 common divisions

    * 类和对象的划分、接口和实现的划分
    * 类型和角色的划分(略

* <img src="final_review_UML.assets\image-20220830210016250.png" alt="image-20220830210016250" style="zoom:80%;" />

  <img src="final_review_UML.assets\image-20220830210027829.png" alt="image-20220830210027829" style="zoom:80%;" />
  <img src="final_review_UML.assets\image-20220830210234621.png" alt="image-20220830210234621" style="zoom:80%;" />
  <img src="final_review_UML.assets\image-20220830210346460.png" alt="image-20220830210346460" style="zoom:80%;" />

# 用例

<img src="final_review_UML.assets\image-20220830164508370.png" alt="image-20220830164508370" style="zoom: 50%;" />

<img src="final_review_UML.assets\image-20220830164604850.png" alt="image-20220830164604850" style="zoom:80%;" />



## 需求

* 需求的两种分类方法：
  * Functional / Non-functional；
    * 用处更多
    * F系统做的事
    * NF系统的质量属性
  * FURPS+
    * 功能性（Functionality）
    * 可用性 Usability
    * 可靠性 Reliability
    * 性能 Performance
    * 可支持性 Supportability
    * +：指一些辅助性的和次要的因素：资源限制、语言工具、硬件；接口的约束、包装、授权许可证等
* 需求分析，**用例视图**从软件产品的**使用者**的角度，而不是开发者的角度。分析动态行为，讨论what而非how
* <img src="final_review_UML.assets\image-20220830170556534.png" alt="image-20220830170556534" style="zoom:80%;" />

## 系统边界

* from user view： 软件系统通过其**边界**呈现给用户的特性。呈现在软件系统的边界上的外部特征是由软件系统的内部实现决定的
* from developer view： 软件系统不是孤立存在的，它的使用价值是通过和它所存在的环境发生交互实现的。因此在描述软件系统的边界、分析软件系统应具备的功能时，应首先分析软件产品与外界环境的联系
* 系统边界描述了系统内部与外部之间**交互的集合**。系统是相对的，相对于开发人员所要分析解决的问题领域。系统边界随着所处的视点（view）不同而变

## 参与者 Actor

* 位于系统之外并和系统进行交互的一类事物。可以对软件系统与外界发生的交互进行分析和描述
* 参与者是人时，用“小人图”；参与者是系统时用方框图
  <img src="final_review_UML.assets\image-20220830171227168.png" alt="image-20220830171227168" style="zoom:67%;" />
* 软件系统的使用者(员工，老板)
* 直接和软件系统交互的软件系统赖以运行的软/硬件(OS)
* 与软件系统有信息交换的计算机外部设备

## 用例

* 软件系统的功能和其代表的动态行为是用**用例**来建模的
* 指定软件系统参与者以后，需要详细描述系统参与者和系统**交互的具体内容**
* **用例定义**：系统为响应参与者引发的一个事件而执行的一系列的处理/动作
* 用例是软件系统的**功能划分**
* 用例的名字分为简单名字&路径名字（不常用）
* **用例的寻找**
  * <img src="final_review_UML.assets\image-20220830184116995.png" alt="image-20220830184116995" style="zoom:80%;" />

### 用例图

系统边界、系统参与者、用例。它们之间的关系可以是：**关联**关系、**依赖**关系

<img src="final_review_UML.assets\image-20220830185308187.png" alt="image-20220830185308187" style="zoom:80%;" />

* 例子
  <img src="final_review_UML.assets\image-20220830185412992.png" alt="image-20220830185412992" style="zoom:80%;" />
  <img src="final_review_UML.assets\image-20220830185452853.png" alt="image-20220830185452853" style="zoom:80%;" />
* 参与者与参与者：
  * **泛化**关系
    <img src="final_review_UML.assets\image-20220830185738810.png" alt="image-20220830185738810" style="zoom:80%;" />
* 用例与用例：
  * **泛化**关系 
    * 发出订单  ~ 网上发出订单
  * **包含**关系 《includes》
    * 子用例是一个常用功能块，基用例必须包含了子用例才能正常进行。**被**包含的那个用例一般不能单独存在
    * <img src="final_review_UML.assets\image-20220830190908279.png" alt="image-20220830190908279" style="zoom:80%;" />
  * **扩展**关系《extended》
    * 子用例是独立的用例，完成一定的功能。基用例可以独立于扩展用例单独存在
    * 当一个用例有多个子流程时，可以用扩展关系使得此基用例的不同子流程能在不同的条件下以扩展用例的形式被激活
  * <img src="final_review_UML.assets\image-20220830190114464.png" alt="image-20220830190114464" style="zoom:80%;" />
    不能有糖葫芦，即用例之间不能关联
* 例
  <img src="final_review_UML.assets\image-20220830191836426.png" alt="image-20220830191836426" style="zoom:80%;" />

## 事件流

* 事件流构成了用户对系统功能的一次使用。在用例图中必须对事件流进行描述，以构成一个完备的用例模型。对事件流的描述包括四种形式，即：
  * 形式文本
  * 非形式文本
  * 交互图
  * 状态图
* **主事件流**（main flow of events）合法使用、只有一个
* **次要事件流**（alternative flow of events）可包含若干个
* <img src="final_review_UML.assets\image-20220830192632686.png" alt="image-20220830192632686" style="zoom:80%;" />
* <img src="final_review_UML.assets\image-20220830192659491.png" alt="image-20220830192659491" style="zoom:80%;" />
* 案例：
  <img src="final_review_UML.assets\image-20220830192937303.png" alt="image-20220830192937303" style="zoom:80%;" />
  <img src="final_review_UML.assets\image-20220830192948720.png" alt="image-20220830192948720" style="zoom:80%;" />
* **包含关系**
  * <img src="final_review_UML.assets\image-20220830193719511.png" alt="image-20220830193719511" style="zoom:80%;" />
  * <img src="final_review_UML.assets\image-20220830193818419.png" alt="image-20220830193818419" style="zoom:80%;" />
* **扩展关系**
  * <img src="final_review_UML.assets\image-20220830193849196.png" alt="image-20220830193849196" style="zoom:80%;" />
  * <img src="final_review_UML.assets\image-20220830193929964.png" alt="image-20220830193929964" style="zoom:80%;" />
  * <img src="final_review_UML.assets\image-20220830193942761.png" alt="image-20220830193942761" style="zoom:80%;" />

## 实践

<img src="final_review_UML.assets\image-20220830200135450.png" alt="image-20220830200135450" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220830200212440.png" alt="image-20220830200212440" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220830200225106.png" alt="image-20220830200225106" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200241947.png" alt="image-20220830200241947" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220830200258304.png" alt="image-20220830200258304" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200336746.png" alt="image-20220830200336746" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200403265.png" alt="image-20220830200403265" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200426865.png" alt="image-20220830200426865" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200437951.png" alt="image-20220830200437951" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200451786.png" alt="image-20220830200451786" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220830200503428.png" alt="image-20220830200503428" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830200534767.png" alt="image-20220830200534767" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220830200545134.png" alt="image-20220830200545134" style="zoom:80%;" />



# 类

类之间的**关系**

* **依赖**关系 <img src="final_review_UML.assets\image-20220830103634509.png" alt="image-20220830103634509" style="zoom:80%;" />
* **关联**关系 <img src="final_review_UML.assets\image-20220830103642530.png" alt="image-20220830103642530" style="zoom:80%;" />
  * 关联的修饰
    * 名称
    * 角色
    * 多重性
    * 组合/聚合
  * 关联类（比较：连接，link）
* **泛化**关系 <img src="final_review_UML.assets\image-20220830103649680.png" alt="image-20220830103649680" style="zoom:80%;" />
  * 一般与具体
* **实现**关系 <img src="final_review_UML.assets\image-20220830103656000.png" alt="image-20220830103656000" style="zoom:80%;" />
  * 类与接口

**实例化**：类与对象

类的**定义**

* 具有相同属性（数据、信息、状态）、相同行为（方法、操作）的一组对象的描述符
* 真实世界事物的抽象，虚拟概念

类的选择依赖于应用领域application domain

## UML的类表示

<img src="final_review_UML.assets\image-20220830104906792.png" alt="image-20220830104906792" style="zoom:80%;" />

* **类名**
  * 必备
  * 简单名字
  * 复杂名字：路径名（包名）::
* **属性**
  * 属性名必备，其余可省略
  * 必须为每个属性指定数据类型：**属性名:类型**
  * 属性可以在类型后面设**初始值**，如：**position : string = teacher**
  * 没有初始值的属性值是不确定的
  * 属性**可见性**
    * public(+)
    * private(-)
    * protected(#)
    * implementation(~)    --means that the class is accessible only by the implementation of the package containing the class
* **操作**
  * 是一个类所能提供的服务的实现，对一个对象所完成功能的抽象，并且由这个类的所有对象共享
  * 操作名必备，名字后需要有()表示是操作
  * 可有**参数表**
  * 可有**返回值**
  * 操作可以引起对象状态的改变；操作可以为服务的请求者组合提供返回值
  * **操作署名**operation signature：**参数名称 : 参数类型 = 参数缺省值**
* 没有必要在模型图上把所有的属性和操作都绘制在模型图上，隐藏一些对表达问题不重要的属性或操作。属性分隔区或操作缺失或分隔区内没有内容并不表示此类没有属性或操作，有可能它们是被省略了
* **职责**
  * 一个类只应承担一种职责
  * 类的职责划分的好坏，决定了设计方案的内聚性及耦合性
  * 为类分配职责，是对类进行建模的**第一步**。类所应具备的属性和操作，将根据类的职责给出

## 依赖关系 dependency

* 把依赖画成一条有向的虚线，**指向被依赖**的事物
* 依赖本身可以带一个名字
* <img src="final_review_UML.assets\image-20220830141201719.png" alt="image-20220830141201719" style="zoom:80%;" />

## 泛化关系 generalization

* 是一般事物（称为超类或**父类**）和该事物的较为特殊的种类（称为**子类**）之间的关系
* <img src="final_review_UML.assets\image-20220830141312751.png" alt="image-20220830141312751" style="zoom: 67%;" />

## 关联关系 association

* 自身关联reflexive association： It means that the objects of that class have links to other objects of the same class
  <img src="final_review_UML.assets\image-20220830141859242.png" alt="image-20220830141859242" style="zoom:80%;" />

* 修饰

  * 名称及其**方向**

    <img src="final_review_UML.assets\image-20220830142451108.png" alt="image-20220830142451108" style="zoom:80%;" />

  * **角色**：在关联的每一端，表明相连的类在该关联关系中的**作用**；**可见性**
    <img src="final_review_UML.assets\image-20220830142712519.png" alt="image-20220830142712519" style="zoom:80%;" />

  * **多重性** Multiplicity

    * 没有默认多重性，没有指定就不确定
    * <img src="final_review_UML.assets\image-20220830143116637.png" alt="image-20220830143116637" style="zoom:80%;" />
    * 远端可能存在多少对象
      <img src="final_review_UML.assets\image-20220830153649997.png" alt="image-20220830153649997" style="zoom:80%;" />

  * **聚合**Aggregation

    * ‘整体’有**管理** ‘部分’的特有的职责。它用端点带有**空菱形**的线段表示，空菱形与‘整体’类相连接
      <img src="final_review_UML.assets\image-20220830153914018.png" alt="image-20220830153914018" style="zoom:80%;" />

  * **组合**Composition

    * ‘整体’**拥有**‘部分’的生命；它用端点带有**实菱形**的线段表示，实菱形与‘整体’类相连接
      <img src="final_review_UML.assets\image-20220830153958188.png" alt="image-20220830153958188" style="zoom:80%;" />

  * **导航性**Navigability

    * 一般不要导航性。除非 导航的意义特别明确和重要！

  * 关联类

    * <img src="final_review_UML.assets\image-20220830160120140.png" alt="image-20220830160120140" style="zoom:80%;" />

## 关系建模

<img src="final_review_UML.assets\image-20220830160622149.png" alt="image-20220830160622149" style="zoom:80%;" />

<img src="final_review_UML.assets\image-20220830160631914.png" alt="image-20220830160631914" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220830160643882.png" alt="image-20220830160643882" style="zoom:80%;" />



* <img src="final_review_UML.assets\image-20220830163618057.png" alt="image-20220830163618057" style="zoom:80%;" /><img src="final_review_UML.assets\image-20220830162627177.png" alt="image-20220830162627177" style="zoom:80%;" />
* <img src="final_review_UML.assets\image-20220830162729999.png" alt="image-20220830162729999" style="zoom:80%;" /><img src="final_review_UML.assets\image-20220830162740831.png" alt="image-20220830162740831" style="zoom:80%;" />
* <img src="final_review_UML.assets\image-20220830163334015.png" alt="image-20220830163334015" style="zoom:80%;" /><img src="final_review_UML.assets\image-20220830163349846.png" alt="image-20220830163349846" style="zoom:80%;" />
* <img src="final_review_UML.assets\image-20220830163423039.png" alt="image-20220830163423039" style="zoom:80%;" /><img src="final_review_UML.assets\image-20220830163432339.png" alt="image-20220830163432339" style="zoom:80%;" />
* <img src="final_review_UML.assets\image-20220830163501736.png" alt="image-20220830163501736" style="zoom:80%;" /><img src="final_review_UML.assets\image-20220830163511114.png" alt="image-20220830163511114" style="zoom:80%;" />

# 交互图 通信图

## 实例

* 抽象概念的具体存在，被称为实例

* 类的实例：**对象**

  * 可以描述软件系统的动态行为（通过状态图、对象图）
  * 可以描述软件系统的动态行为的实施过程（交互图）

* 用例的实例（协作、场景）

* 节点的实例可以描述运行时物理资源的分布情况

* **关联**的实例：**Link连接**

* 实例的命名

  * [名称] ：[类型]

  * 名称是一个带有**下划线**的字符串

  * **具名实例**： c1:ClassA ， c1

  * **孤体实例**（orphan objects ）

  * **匿名实例**：只有类型名

  * 一个实例有一个类型。实例的类型必须是具体的类目（classfier）（或类）

  * <img src="final_review_UML.assets\image-20220829190305013.png" alt="image-20220829190305013" style="zoom:80%;" />

    <img src="final_review_UML.assets\image-20220829190220654.png" alt="image-20220829190220654" style="zoom:80%;" />

## 交互

* **对象**之间为实现某一功能，必须实施的协作过程、动态行为，称为**交互**
* 交互的建模元素：**对象**，**参与者**，**消息**
* 交互的对象既可以是具体的事物（学生张三丰、学生王海），又可以是**原型化**（学生甲、学生乙）的事物

## 消息

* 一个对象以某种方式**启动**另一个对象的活动
  <img src="final_review_UML.assets\image-20220829191421636.png" alt="image-20220829191421636" style="zoom:80%;" />
* 调用call：启动某个对象的操作
* 返回return：向调用者返回一个值
* 发送send：向一个对象发送一个信息
  * 同步
  * 异步（多线程）
* 创建create：发送导致目标对象被创建
* 销毁destroy：导致目标对象被销毁
* <img src="final_review_UML.assets\image-20220829193308167.png" alt="image-20220829193308167" style="zoom:80%;" />
* 在顺序图垂直方向上，由上而下**顺序**执行（顺序号）

## 连接

* 关联的实例
  <img src="final_review_UML.assets\image-20220829194922314.png" alt="image-20220829194922314" style="zoom:80%;" />
* 约束修饰（不能用多重性修饰连接，因为是实例）
* Association
  * 说明对应的对象通过关联是可见的
    <img src="final_review_UML.assets\image-20220829195122653.png" alt="image-20220829195122653" style="zoom:80%;" />
* Self
  * 说明对应的对象， 因为是本操作的调遣者，所以是可见的
* global
  * 说明对应的对象在全局范围内可见
* local
  * 说明对应的对象在局部范围内可见
* parameter
  * 说明对应的对象 因为是一个参数，所以是可见的



## 交互图 Interaction Diagram

* 分为**顺序图**（消息的**时间顺序**），**通信图**（强调接收和发送消息的对象的**组织结构**）
* 可以互相转换，顺序图和交互图语义是等价的

### 顺序图**Sequence diagram**

* 每个对象的底部中心都绘有一个垂直虚线，称为**对象生存线**（object lifeline）
* 对象生存线上的“长条矩形”Focused（**控制焦点**），表示这段时间对象在进行操作
* **结构化控制**（frame，fragment）：
  * 可选执行 （标签: opt)
  * 条件执行 （标签:alt)
  * 并行执行 （标签:par)
  * 循环（迭代）执行 （标签:loop)
  * <img src="final_review_UML.assets\image-20220829201408403.png" alt="image-20220829201408403" style="zoom: 80%;" />
    嵌套顺序图：
    <img src="final_review_UML.assets\image-20220829201553141.png" alt="image-20220829201553141" style="zoom:80%;" />
* <img src="final_review_UML.assets\image-20220829201716828.png" alt="image-20220829201716828" style="zoom:80%;" />
  <img src="final_review_UML.assets\image-20220829202613989.png" alt="image-20220829202613989" style="zoom:80%;" />
* 建模时，先在类中定义操作，然后在顺序图中为对象**选择**操作
  <img src="final_review_UML.assets\image-20220829202238618.png" alt="image-20220829202238618" style="zoom:80%;" />

### 通信图**Communication diagram** 

* 通信图的构成：**对象**，**连接**，在此连接上传递的**消息**
* 在通信图上，**连接**用对象之间相连的**直线**来表示
* 如果有消息借助此连接关系传递，则把消息的图符沿直线方向绘制，消息的箭头指向接受消息的对象
* 仅从图符的绘制上无法在通信图上读出消息发送的顺序，所以通常在消息上保留消息**顺序号** （和顺序图一样）
* ![image-20220829221808904](final_review_UML.assets\image-20220829221808904.png)
  ![image-20220829221816658](final_review_UML.assets\image-20220829221816658.png)
  ![image-20220829221827013](final_review_UML.assets\image-20220829221827013.png)

### 顺序图和通信图的区别

* 二者在语义上是等价的，可以相互转化
* 通信图显示对象之间是如何被**连接**（{local} {global}）但顺序图没有
* SD显示消息的返回、有对象**生命线**、控制**焦点**，但是通信图没有

### 代码和SD的映射

<img src="final_review_UML.assets\image-20220829223140841.png" alt="image-20220829223140841" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220829223157918.png" alt="image-20220829223157918" style="zoom:80%;" />
<img src="final_review_UML.assets\image-20220829223212993.png" alt="image-20220829223212993" style="zoom:80%;" />

# 活动图(activity diagram)

## 活动&动作(activity&action)

* activity：一个业务过程中进行的**非原子**的执行单元
* action：**原子**的，不可分解。不再细分的活动。
* UML里活动和动作的符号一样

## 活动图

活动图是顶点和弧的集合，显示从活动到活动的流

* 活动节点：上下平行，左右圆弧。可以有名字，可以是伪代码描述。放大一个活动节点可以看到另一个活动图。活动节点会持续一段时间来完成动作
* 流：树杈箭头。控制流从一个节点传到另一个节点。
* 分支：菱形。
  * 分支节点：可以有一个进入流和多个离去流，每个离去流必须设置一个监护条件，条件放在方括号里且不能重叠以免二义性。可以有[else]分支。
  * 合并节点：条件分支的结束。两个控制路径可以重新合并，此时多进一出，不需监护条件。
  * 迭代：
    <img src="final_review_UML.assets\image-20220819161834977.png" alt="image-20220819161834977" style="zoom:50%;" />
* 对象值：矩形，里面有名称、冒号、下划线
* 注解和约束：和别的地方一样的。（大括号约束、标记值）

活动：entry、do、exit

## 分岔&汇合(Forking & Joining)

* 分岔：把一个单独的控制流分成多个并发的控制流
* 汇合：多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移
* 同步棒：一条水平或垂直的粗线条，来说明并行控制流的分岔河汇合
* 并发流程控制：分岔和汇合条表示并发控制流 concurrent。分岔和汇合条，既可以表示线程活动也可以表示用户并发活动。多重性指标指明有多少并发的行为必须被处理
  <img src="final_review_UML.assets\image-20220819163548491.png" alt="image-20220819163548491" style="zoom:50%;" />

## 泳道(swimlanes)

* 将一个活动图中的活动分组，每一组表示某个业务组织负责的活动集
* 一个特定的类、人或部门，他们负责完成组内的活动
* 每个组被称为一个泳道，用一条垂直或水平的实线把它们分开
* 每个泳道在图中都有一个唯一的名称
* 每个活动**严格**地属于一个泳道，职责明确
  * 转移、同步棒可以跨泳道
* 泳道是包（package）的一种，分门别类的组织活动

## 对象流(object stream)

* 把对象包含在与一个活动图相关的控制流当中
* 箭头将它们连接到产生或使用这些对象的活动节点上，活动可以创建对象、修改对象状态
  <img src="final_review_UML.assets\image-20220819172617724.png" alt="image-20220819172617724" style="zoom: 67%;" />

## 活动节点嵌套

* 活动可以展开
* rake符号，放大一个活动节点，可以看到另一个活动图

## 活动图的应用

* 描述一个任务执行过程中所完成的工作（动作），这是活动图最常见的用途
* 描述对象内部的工作
* 显示如何执行一组相关的动作，以及这些动作如何影响它们周围的对象
* 显示用例的实例如何执行动作以及如何改变对象状态
* 说明一次业务流程中的人（参与者）和对象是如何工作的
* 活动图是**用例图的补充**说明，相辅相成

活动图中的基本要素包括**活动**（**动作**）、**转移**、**分支**、**分岔和汇合**、**泳道**、**对象流**、开始结束等

## 活动图建模步骤

* 确定活动图所关注的**业务流程**（了解领域）
  * 不可能使用一个活动图对系统中所有的业务过程建模，通常一个活动图，只用于描述一个业务流程
* 确定该业务流程中的**业务对象**。（和类的实例化对象不一样。人、组织、部门）
* 确定该业务流程的起始状态和终止状态，这有利于确定它的**边界**
* 从该业务流程的起始状态开始，说明随着时间推进，发生的动作和活动，并在活动图中把它们表示成活动**节点**或动作节点
* 将复杂的动作，或多次出现的动作**集合归并**到一个活动节点，并对每个这样的活动 提供一个可展开的单独的活动图
* 找出连接这些活动和动作的转移。首先从工作流的顺序流开始，然后考虑**分支**，接着再考虑**分岔和汇合**
* 如果工作流中涉及**重要的对象**，则也把它们加入到活动图中。如果需要描述对象流的状态变化，则需要显示其发生变化的值和状态

## 活动图&用例

* 主事件流的每一项都是一个活动
* 分支：确定主事件流的条件分支
* 并发流：确定主事件流中的并发活动

<img src="final_review_UML.assets\image-20220820011044397.png" alt="image-20220820011044397" style="zoom:67%;" />
<img src="final_review_UML.assets\image-20220820011136625.png" alt="image-20220820011136625" style="zoom:67%;" />




<img src="final_review_UML.assets\image-20220820011210992.png" alt="image-20220820011210992" style="zoom:67%;" />
<img src="final_review_UML.assets\image-20220820011220563.png" alt="image-20220820011220563" style="zoom:67%;" />

## 正/逆向工程

* 正向：模型--->代码
* 逆向：代码--->模型

似乎是必考
  <img src="final_review_UML.assets\image-20220820005533810.png" alt="image-20220820005533810" style="zoom:50%;" />
<img src="final_review_UML.assets\image-20220820005451730.png" alt="image-20220820005451730" style="zoom:50%;" />

## 小结

* 活动图是UML中用于对系统的**动态**方面建模的五种图中之一（用例图/活动图 / 顺序图/通信图 /状态图）
* 一张活动图从本质上说是一个**流程图**，显示从活动到活动的**控制流** 
* 多数情况下，活动图用于对**业务过程**中**顺序和并发**的工作流程进行建模
* 活动图中的**基本要素**包括：**活动**、**转移**、**分支**、**分岔和汇合**、**泳道**、**对象流** 
* 活动图中还有一类特殊的状态，用于表示活动的**开始和结束**。分别称为起始状态(start state)和终止状态(end state)。 
* **转移**：表示对象将在当前状态中执行动作，并在某个特定事件发生或某个特定的条件满足时进入后继状态。
* **分支**branching：用于描述基于某个条件的可选择路径
* **分岔**fork：表示把一个单独的控制流分成两个或多个并发的控制流
* **汇合**join：表示两个或多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移
* **泳道** swimlanes：将一个活动图中的活动状态进行分组
* 用活动图描述某个**对象**时，可以把所涉及的对象放置在活动图上，并用一个依赖将这些对象连接到对它们进行创建、撤销和修改的活动转移上。这种包括依赖关系和对象的应用被称为**对象流**



# 状态图 State Diagram

* 引入：当需要考察**单个**实体的动态行为时如何UML建模？每个实体有哪些可能的状态？
* 状态图对实例（对象）的动态行为进行建模
* 顺序图与状态图的区别：顺序图研究对象间的协作，状态图研究一个对象的状态

## 状态

* 是对象的生命期中的一个条件或状况
* 在此期间，对象可以响应事件、执行某活动等

**状态无关**

* 简单、独立的行为，或当前的行为并不依赖它们的过去时，**不需要**用一个状态机建模（如：对象的创建、撤销、简单调用另一个对象的操作、偶尔随机发生的动作）

**状态依赖**

* 对象的当前行为依赖于过去，
* 或者它的行为必须响应**异步**消息（啥是异步消息啊？）

**状态机**

* 是一种行为
* 说明对象在它的生命期中, 响应事件所经历的**状态序列**以及它们对**每个事件的响应**

状态图

* 状态机可以用状态图来可视化。
* 状态图显示了一个状态机，它强调从状态到状态的控制流
* 为具有**状态依赖行为的对象**而不是状态无关行为的对象建立状态机图

**概念**

* 名称（name）每个单词首字母大写
* 进入/退出动作(entry/exit action)
* 内部迁移（internal transition）不在此展开了
* 子状态 (substate)
* 延迟事件 (deferred event)

## 事件

* 是对一个在时间和空间上占有一定位置的、有意义的事情的描述
* 在状态机的语境中，一个事件是一个激励的发生，它能够触发一个状态迁移
* UML 对4种事件进行建模
  * 参量变化
  * 信号 signal异步
  * 调用 call同步
  * 时间事件

## 迁移

* 迁移五部分组成：
  * 源状态
  * 事件触发器（触发事件名称）
  * 触发条件
  * 效应（迁移动作）
  * 目标状态
* 自身迁移
* 内部迁移

## 活动&动作

* 活动：占用有限时间，可以中断工作
  * 只在一个状态内部出现
* 动作：瞬时完成，不可以中断工作
  * 出现在一个状态的内部，与内部迁移相关联
  * 出现在一个状态的外部，与外部迁移相关联

## 图形

* 状态
  * 圆角矩形
  * 初始状态：实心圆
  * 结束状态：牛眼（有的状态图没有最终状态，比如嵌入式系统，一旦运行就没有确定的结束时间，也可以加一个故障）
* 事件
  * 触发事件名[触发条件]/迁移动作
  * 上面三个部分可以省略，但是至少保留一部分
* 迁移
  * 叉形箭头实线

## 建模

* 注意事项
  * 不允许孤立的状态存在
  * 不允许只进不出的状态迁移 (“黑洞”)
  * 不允许只出不进的状态迁移 (“奇迹”)
  * 不允许没有事件发生的迁移（或者“迁移” 没有指明具体的事件）

## 比较

* 交互图：动态行为，对共同工作的对象群体的行为建模
* 状态机：动态行为建模，对单个对象的行为建模，潜在的状态和这些状态之间的迁移
* 活动图：强调活动到活动的控制流、多个业务角色。

## 高级概念

* 高级状态和迁移
  * 进入/退出动作
    * 不可以有监护条件
    * 如C++的构造函数、析构函数
  * 内部转换
    * 不同于自身迁移
    * 只执行内部的动作，不执行进入/退出动作
  * Do
    * 当对象处于某种状态时，希望对一个持续的活动建模
    * UML用特殊的do迁移来表示执行了进入动作后在一个状态内部所做的工作
  * 延迟事件
    * 状态A发生事件e，在A中不处理。当系统到达状态B时处理消息e
    * 例如：异步处理转为同步处理
* 子状态机
  * 嵌套在另一个状态中的状态
  * 正交（并发）子状态
    * 一个语境中并发地执行多个状态机
  * 非正交（顺序）子状态
    * 状态不相交，一次是能处于一个子系统
  * 分岔和汇合：从一个外部状态直接迁移到一个或多个正交状态
* 状态图之间的交互
  <img src="final_review_UML.assets\image-20220821163611974.png" alt="image-20220821163611974" style="zoom:67%;" />

## 小结

* 事件(Event)，是指对一个在时间和空间上占据一定位置的有意义的事情的规格说明。
* 事件包括**信号**、**调用**、**时间推移**或**状态改变**。
* 状态（State）是指在对象的生命周期中满足某些条件、执行某些活动或等待某些事件时的一个条件或状况。
* 转换是两个状态间的一种关系，表示对象将在当前状态中执行动作，并在某个特定事件发生而某个特定的条件满足时进入后继状态
* 状态图显示了状态机。活动图和状态图是对一个**对象的生命周期**进行建模，是描述对象随时间变化的动态行为。 活动图显示的是从活动到活动的控制流，状态图则显示的是从状态到状态的控制流 



# 高级类

**review**
<img src="final_review_UML.assets\image-20220822230343421.png" alt="image-20220822230343421" style="zoom:67%;" />

包：了解一下，工作中没那么细致

接口：一组操作的集合，**描述**了类和构件提供的服务（没实现）

## 类目

* 类目是一种描述**行为**特征(以**操作**的形式）和**结构**特征（以**属性**的形式）的模型元素, 是UML中更一般（**更抽象**）的构造块
* 类（class），是类目的一种，但它是**最重要**的类目
* 类目的种类包括：类、关联、接口、数据类型、信号、构件、节点、子系统、以及用例 （参见text ch9.2）
*  类目（尤其是 类）的简单特征： **属性**、**操作**
* **类目高级**特征：可见性、作用域、多重性、多态性、模版类、标准类等。类的大多数特性都适用于类目，通常只是为每种类目增加了某些特殊限制条件。
* **注意**：
  * UML中有一些事物**没有实例**，如**包**和**泛化**关系，就不属于类目（关联关系的实例是Link，所以是类目）
  * 类目有多种类别。但最最主要的还是 **类**Class



**类目图形表示**

<img src="final_review_UML.assets\image-20220822235000931.png" alt="image-20220822235000931" style="zoom:80%;" />

包+构造性 --> 子系统
<img src="final_review_UML.assets\image-20220822235018517.png" alt="image-20220822235018517" style="zoom:80%;" />

## 可见性

描述了类目的构成（如属性和操作）能否为其他的类目所使用

* **公用可见性**（public +），类目的构成可以被任何别的类目访问
* **保护可见性**(protected #)，类目的构成可以被此类目的导出类目访问
* **私有可见性**(private -)，类目的构成只能被此类目本身的操作访问
* **模型包可见性**(package ~) ：仅可以被定义在同一模型包内的类目访问

## 作用域

* **实例作用域**(instance)（有时称为对象作用域） 
  * 对于一个特征（feature），类目的每个实例均有它自己的值
* **类目作用域**(static)
  * 对于类目的所有实例，特征的取值是唯一的
  * 如果一个操作具有类作用域，则意味着此操作的结果对整个类有效
    * 对C++而言，具有类作用域的类的构成，相当于是静态(static)变量和静态函数
    * （在C++里，如果一个函数是静态的，就意味着此函数只能访问静态变量）

<img src="final_review_UML.assets\image-20220823000142406.png" alt="image-20220823000142406" style="zoom:80%;" />

**作用域图形化表示：**

* 如果类构成（属性+操作）的名字下面加了**下划线**，就表示此构成具有类作用域，否则就具有实例（对象）作用域
  <img src="final_review_UML.assets\image-20220823000533720.png" alt="image-20220823000533720" style="zoom:67%;" />（静态的，类作用域）

## 抽象类

* 没有直接实例的类，是**抽象类**（一般是基类，不会被实例化为对象）
  * 在图形表示上，把抽象类的名字用**斜体字**拼写。大多数类叫做具体类，不特殊标注
* 抽象类的方法可以未定义，成为**抽象操作**，将在导出类里定义。抽象操作的名字用斜体

## 多态性

* **多态性指的是在泛化关系的层次结构中，处于不同层次的导出类的相同署名(signature) 的操作，可以有不同的动态行为（△背住体会）**

## 叶子类&根类

* 叶子类是没有任何导出类的类
  * 图形表示：把{leaf}用花括弧扩起来，放置在类名的下方，表示对类的约束
* 根类是没有任何基类的类（不一定是抽象类）
  * 图形表示： 把关键字{root}, 放置在类名的下方，表示对类的约束

## 类多重性（multiplicity）

* 对类的**可同时存在的对象的数目加以限制**，称为类的多重性。多重性描述的是一个数目范围，数目范围用一个表达式描述。
* 比较：关联关系的多重性
  * 声明了关联关系本端的多重性，这就说明：对于关联另一端的类的每个对象，本端的类可能有多少个对象出现

下面表示是一个叶子类，可以同时存在33个对象
<img src="final_review_UML.assets\image-20220823010914193.png" alt="image-20220823010914193" style="zoom:67%;" />

* 和关联关系的多重性的含义表示是一样的

  * 

  * | 形式              | 含义                                                |
    | ----------------- | --------------------------------------------------- |
    | N                 | 对可以同时存在的对象数目没有限制                    |
    | 1                 | 有且只能有一个对象                                  |
    | 1..n              | 必须有至少一个对象存在                              |
    | 0..n              | 可以有零个或任意多个对象存在                        |
    | 0..1              | 可以有零个或一个对象存在                            |
    | <大于等于1的整数> | 必须有指定数量的对象存在                            |
    | 2..10             | 必须至少有2个对象存在，但不能有超过10个对象同时存在 |

类多重性、属性多重性
<img src="final_review_UML.assets\image-20220823011424438.png" alt="image-20220823011424438" style="zoom: 50%;" />

## 属性/操作的完整语法

* 类的属性构成：

  * 名字、可见性、类型、多重性、初始值、作用域、可变性
* **属性**的完整语法（方括号表示可省略）：
  * **[可见性]名字\[多重性]［:类型][=初始值]［{特性串}］**
  * **[可见性]名字\[类型]\[多重性][=初始值]［{特性串}］**
  * {特性串}通常是{changeable}或者{readonly}
  * 合法属性声明
    <img src="final_review_UML.assets\image-20220823012649709.png" alt="image-20220823012649709" style="zoom:67%;" />
* **操作**的语法具有下面的形式：
  * **[可见性]名字([参数表])［:返回类型］[{特性串}]**
  * 其中，名字、参数表、返回类型合在一起，又称为**操作署名**(signature)
  * **操作署名可以含有**0个或多个参数：格式为  [传递方向]名字:type[=缺省值]
    * 其中，传递方向可以取三个关键值，它们是：
      * <1>、in：它标识本参数是输入的输入值，操作完成后本参数的取值将不被改动
      * <2>、out：表明本参数是操作的输出参数，操作完成后本参数的取值将被修改
      * <3>、inout：表明本参数是一个输入参数，但在操作完成后，参数的取值可被修改
  * 特性串
    * 特性串是一个UML约束，它对操作的语义进行附加的修饰
    * 除了前面提到的叶子操作{leaf}，{abstract}外，还可以使用下面的特性约束（这些形式化研究生有用）
      * **isQuery**（query）：它表明被修饰的操作是一个用于查询的操作
      * **Sequential**：表明被修饰的操作在其对象内不能同时有两个以上的控制流。而这一点必须由操作的调用者来保证
      * **guarded**：调用者可以同时启动此操作的多个控制流，但这些控制流被对象自身转换为顺序执行的控制流。这意味着当多个控制流被同时启动时，此操作的控制流或者正常执行，或者被自我阻塞，直至没有其它控制流在正常执行为止
      * **concurrent**：操作可以有多个控制流被同时启动，且正常的控制流可以同时运行，但操作的语义和完整性仍可保证
  * 合法的操作声明
    <img src="final_review_UML.assets\image-20220823014635865.png" alt="image-20220823014635865" style="zoom:67%;" />



## 模板类

* 模板类是一个**参数化**的类
* 模板类和实际类的区别
  * 模版类定义了一系列的形式参数
  * **形式参数**代表特定的类、对象和值，它们可以在模版类中被引用，而且其作用域只局限在模版类中
  * 在模版类的操作中,通过引用此形式参数的符号来定义对形式参数的处理
* 模版类本身不能被直接使用。只有在为其中的形式参数指定了实际参数以后，才构成了一个能在软件系统中使用的类
* 因此，一个模版类可以构造一系列不同的类，它定义了一个类的家族。这只需为模版类指定不同的参数就可实现
* 模版类又被称为参数化的类（parameterized class）
  * **绑定**bind：在UML中，模版类的形式参数和实际参数的的结合，称为绑定
  * **实例化**instantiate：通过绑定，用模版类定义具有明确语义的实际类的过程，则称为模版类的实例化。产生的类叫作**实例化的类**instantiated/bound class
* 可以用绑定关系来把模版类和实例化的类联系起来
  * 绑定关系是依赖关系的一个变体，它用<\<bind>>修饰，其后面是用括号括起来的绑定的实际参数列表
  * 绑定关系的箭头指向的类是模版类。箭头起始端是实例化的类
    <img src="final_review_UML.assets\image-20220823120546576.png" alt="image-20220823120546576" style="zoom: 67%;" />

## 标准元素

UML里通过约束、变体和标记值等扩充机制预定义的一些关键字，它们被称为**标准扩充**（这部分是形式化建模的东西，可以**了解即可**）

* **元类**metaclass ：说明一个类目，其对象全是类
  * 通常用来定义元模型（metamodel）
  * 元类是定义类的类。n在模型图上，如果在类的名字的上方标以关键字<\<metaclass>>，就代表此类是元类
* **幂类型**powertype: 说明一个类目。其对象是给定父类的子类
  <img src="final_review_UML.assets\image-20220823121918965.png" alt="image-20220823121918965" style="zoom: 80%;" />
* 构造型 stereotype:说明一个类目是可用于其它元素的构造型
  <img src="final_review_UML.assets\image-20220823121927656.png" alt="image-20220823121927656" style="zoom: 67%;" />
* 实用程序utility：说明一个类，它的属性和操作都是类作用域

# 高级关系

UML四种关系：依赖、关联、泛化、实现

## 依赖

* 源-------->目标

* 类与类；包与包；对象和类（类型与角色；略）

* 类或对象之间的关系

  * **绑定依赖**《bind》
    * 它的箭头指向一个模版类，箭头的起始端的类是一个实例化的类，标明源类是目标类的实例化

  * **导出依赖**《derive》
    * 一个类的两个属性是互不独立的，例如Person类的生日和年龄属性
    * 为了表明一个类或对象可以从另一个 计算得出，可以用导出依赖（derive）表示

  * 允许《permit》
    * 表示源从目标获得特定的可见性（Iterator）

  * 《instanceOf》

  * 《instantiate》

  * 幂类型《powertype》
    * 目标是源的幂类型。幂类型是一个类目，其对象都是一个给定父类的子类

  * 精化《refine》
    * 表示**源**比目标处于**更精**细的抽象程度上

  * 使用《use》 可以省略

* 包之间的依赖关系（略）
  * 引入《import》可以继续输出
  * 访问《access》不可继续输出
* 用例之间的依赖关系
  * 《include》
  * 《extend》
* 对象之间的交互（实时系统建模，如嵌入式）
  * 发送《send》：源类发送目标事件
  * 跟踪《trace》：目标是源的早期开发阶段的祖先

## 泛化关系

大部分情况下，单继承已满足需要

* {complete} 完全
  * 泛化模型中子类已经完全列出，不可以再增加子类
* {incomplete} 不完全
  * 子类没有完全列出，可以增加子类
* {disjoint} 互斥
  * 父类的对象最多以给定子类中的一个子类作为类型（无法多态）
* {overlappin}g 重叠
  * 父类的对象可能以给定的子类中的一个以上子类作为类型

## 关联关系

关联名、关联端角色、多重性、聚合

* 导航
  * 两个类之间的简单无修饰的关联
  * 一般导航双向的
  * 有限制时导航是单向的（加箭头，情况很少，不加也行）
* 可见性
  <img src="final_review_UML.assets\image-20220823154818088.png" alt="image-20220823154818088" style="zoom: 80%;" />
* 限定 
  * 是关联的一个属性，它的值通过关联限定了与一类对象相关的对象子集
    <img src="final_review_UML.assets\image-20220823160545118.png" alt="image-20220823160545118" style="zoom:80%;" />
* 关联类
  ![image-20220823160703130](final_review_UML.assets\image-20220823160703130.png)
* 聚合
  ![image-20220823160757784](final_review_UML.assets\image-20220823160757784.png)
* 组合
  ![image-20220823160811706](final_review_UML.assets\image-20220823160811706.png)
* 约束
  * 有序{order}
    * n表示关联一端的对象是显示有序的
      ![image-20220823161235637](final_review_UML.assets\image-20220823161235637.png)
  * 集合{set}
    * 对象唯一，不可以重复
  * 袋{bag}
    * 对象不唯一，可以重复
  * 有序集合{order set}
    * 对象唯一且有序
  * 表{list}或者序列{sequence}
    * 对象有序但可以重复

## 实现关系

* 实现是类目之间的语义关系
* 大多数情况下，实现用来描述
  * 类与构件、接口或子系统之间的关系
  * 用例和实现该用例的**协作**之间的关系
    * 协作（Usecase Realization == 顺序图）
* 一条带有空心三角箭头的虚线，并指向描述合约的那个类目（接口）
  ![image-20220823162356856](final_review_UML.assets\image-20220823162356856.png)



# 接口&包

## 引言

* 类 Class
  * 软件系统的内部是由大量的互相关联的类构成的
* 构件 component
  * 系统的一个物理的可替换的部分，它遵从一组接口的要求，并提供对这些接口的实现
  * 构件是由**类**、**子构件**组成的，能够完成相对独立的子功能
* 模型包、子系统《subsystem》
  * 软件系统中的类/构件，依据其所起的作用，形成子集，即模型包，有时称为 子系统；子系统也可以是构件
  * 子集之间的耦合则比较松散
* 接口
  * 为类或构件设定一个外部行为特性的规范，对类或构件的修改不改变这个行为规范，就可以保证其它与之关联的部分、乃至整个系统能正常工作。这样的规范，在UML里被称为 **接口**(interface) 
  * 接口为构件指定外部行为特征，从而能够实现软件系统的构件化，即，遵循同一个接口的构件可以互相替换

## 接口定义

* 接口
  * 是一系列操作的集合，它指定了一个类或者一个构件所能提供的服务
  * 接口只能拥有操作，**不能拥有属性**
  * 通过接口连接的类或构件之间的耦合是松散耦合
* 名字
  * 简单名
  * 路径名（模型包名和简单名字之间用两个冒号分隔）
* 图形
  * 接口是类的**构造型**, 关键字是《interface》
  * 或者用一个圆圈表示

## 接口操作

* **接口的操作**
  * 接口不同于类，它不描述任何实现

* 不得为接口指定属性
  * 在建模时，通过接口, 可以概括地了解类或构件的外部特性，而不必关心它们的内部实现和结构
  * 在系统实现时，可以通过接口的定义，实现功能构件的替换或扩充
  * 由于被接口描述的类或构件，对外部必须具有低的耦合度，所以不应把类或构件的内部结构, 即属性，暴露出来因此，UML规定不得为接口指定属性

## 接口的实现关系

* 接口强调的是类、子系统或构件的**外部行为规范**，它不强调此动态行为的实现方法。
* 不同的类或构件只要它们的实现遵循同一个接口就可以在交互中互换
* 一个接口的动态行为
  * 可以用一个**类**来实现，
  * 可以用一个**构件**来实现
  * 一个接口可以有多种实现方法
* 在使用UML为软件系统建模的时候，如果要描述某个类或某个构件实现了给定的接口，可以使用实现关系
* **实现关系**是两个类目之间的语义关系，表明其中的一个类目（接口）为另一个类目规定了应实现的合约
* 实现关系可以连接的类目包括
  * 接口和**类**
  * 接口和**构件/子系统**，
  * 用例和协作。用例实现 画在class model里，即**顺序图**
  * 接口规定了类或构件的动态行为，用例规定了协作的动态行为
  * 接口没有直接的实例
    <img src="final_review_UML.assets\image-20220825091534676.png" alt="image-20220825091534676" style="zoom:80%;" />
    <img src="final_review_UML.assets\image-20220825091558531.png" alt="image-20220825091558531" style="zoom:80%;" />
* **供接口**（provided interface)
  * 类或构件承诺提供的一组服务
  * 供接口是**实现关系**
* 需接口（required interface）
  * 类或构件所需要的来自其他类的服务集合。需接口是**依赖关系**

<img src="final_review_UML.assets\image-20220825092058172.png" alt="image-20220825092058172" style="zoom: 67%;" /><img src="final_review_UML.assets\image-20220825092106887.png" alt="image-20220825092106887" style="zoom: 50%;" />

系统中的接缝建模
<img src="final_review_UML.assets\image-20220825092712692.png" alt="image-20220825092712692" style="zoom:50%;" />



## 包

* 模型包是纯粹概念化的建模元素，在模型代表的软件系统的**运行时刻**，模型包是不会存在于其中的，即模型包不可能被**实例化**
* 模型包可以拥有的元素
  * 类、接口、构件、节点、协作、用例和图，子包
* 一个元素只属于一个包



# 进程&线程

## 主动类

* 主动类是一个类，实例是**主动对象**，拥有一个或者多个进程|线程
* 主动对象可以**独立运作**、决定自己的行为
* 主动类也是一种类，它的实例行为与其它实例行为之间可以**并发**执行
* 主动对象拥有一个进程或线程，并能够启动控制活动

<img src="final_review_UML.assets\image-20220825132218267.png" alt="image-20220825132218267" style="zoom:80%;" />

* 可以将每一个独立的**控制流**建模为一个主动对象。它代表一个能够启动控制活动的进程与线程

* UML用主动类表示进程或者线程

  * 在（主动）类符号、构件符号的基础上进行构造（在类符号上进行构造，也可以，但不是很严谨）
  * 《thread》、《process》

* 主动类的行为，可以用**状态机**来说明

* 主动类可以参与**协作**： 其对象出现在顺序图中（主动类的行为可以通过**顺序图**来体现）

## **通信**

在一个既有主动对象，又有被动对象的交互中

* 消息在被动对象之间传递

  * 一个时间点只有一个控制流
* 消息从一个主动对象传送到另一个主动对象

  * 进程间的通信：同步调用、异步调用
* 消息从一个主动对象传送到一个被动对象

  * 如果在一个时间点上，有多于一个 主动对象通过一个被动对象传送它们的控制流 ，那么就出现了潜在的冲突
* 消息从一个被动对象传送到一个主动对象

## **同步**

* critical object 临界对象
  * 任何时刻，只允许一个控制流访问的对象
* 对临界的3种建模方法
  * 顺序的 sequential：调用者必须在**对象外部**进行协调
  * 监护的guarded：把多个控制流对受监护对象的多个操作，顺序化
  * 并发的 concurrent: 当有多个控制流时，多个控制流存取不想交的数据集合，或者只读取数据

## 并发状态建模

* 把一个对象的状态机（就是个主动对象）划分成两个或者多个并发区域
  * 正交子状态（并发）：把一个人看做对象，看书– 等人
  * 非正交子状态（顺序）：游泳、开车
*  使用主动对象，每一个负责一个并发区域的行为。实现正交子状态 、非正交子状态



# 构件图&部署图

## 构件图

* 构建

  * 定义了良好接口的**物理实现单元**，它是系统中可替换的部分
  * 每个构件体现了系统设计中特定类（ 或多个类）的实现

* 构件可以分为以下三种类型

  * 实施构件（DLL，EXE，JavaBean）
  * 工作产品构件（源码文件，数据文件）
  * 执行构件

* 构件图

  * 是对面向对象系统的**物理方面建模**时使用的两种图之一（另一种图是部署图） 
  * 构件属于**实现视图**（Implementation view）
  * 基本组成
    * 构件(component) 
    * 接口(interface) 
    * 关系(relationship) 
    * 还可以含有包（package）和子系统(subsystem) ，它们有助于将系统中的模型元素组织成更大的组块

* 构件和类

  * 相同
    * 有名称
    * 可以实现一组接口
    * 可以参与依赖、泛化、关联关系
    * 可以被嵌套
    * 可以有实例
    * 可以参与交互
      <img src="final_review_UML.assets\image-20220825163803574.png" alt="image-20220825163803574" style="zoom:80%;" />
  * 差别
    * 类表示**逻辑**抽象，构件表示计算机中的**物理**抽象
    * 类直接拥有属性和操作；一般构件只能通过接口访问操作

* 构件和接口

  * 接口：一组操作的集合，指明了由类或构件所请求或者所提供的服务
  * 构件：遵循并提供了一组接口的实现。供接口（构件向其他构件提供的作为一个**服务**） + 需接口（构件向其他构件请求服务时所**遵循**），通过不同的多个端口来实现

  <img src="final_review_UML.assets\image-20220825164411422.png" alt="image-20220825164411422" style="zoom:80%;" />

* 构件主要成分

  * 部分part
    * 构件内部基本的实现单元，如计算，存储
    * 部件有名字和类型
    * 部件在其所在构件内有多重性
    * <img src="final_review_UML.assets\image-20220825164857343.png" alt="image-20220825164857343" style="zoom:80%;" />
  * 端口port
    * 被封装的构件的特定窗口，遵循指定接口的构件通过它来收发消息
    * 端口符号不一定画出来
    * <img src="final_review_UML.assets\image-20220825164944997.png" alt="image-20220825164944997" style="zoom: 80%;" /><img src="final_review_UML.assets\image-20220825165001900.png" alt="image-20220825165001900" style="zoom:67%;" />
  * 连接件connector
    * 是一种规则，指导有端口的构件之间互连，以构成构件的内部结构
    * 可以把构件连接起来，形成复合构件或系统
    * 连接件有时也称为：配置（configuration)、拓扑
    * 连接件有两种方式： 
      * 直接连接
      * “托球—托座”：通过接口的方式互连
    * <img src="final_review_UML.assets\image-20220825165331376.png" alt="image-20220825165331376" style="zoom:80%;" />

* 关系

  * 在面向对象的建模中，最重要的关系是**依赖**、泛化、关联和**实现**
  * 依赖关系维持的时间不长。使用虚线箭头表示

<img src="final_review_UML.assets\image-20220825184110014.png" alt="image-20220825184110014" style="zoom:80%;" />

## 部署图

* 部署图（deployment diagram) 展示**运行时**进行处理的节点和在节点上生存的制品（artifact）的配置
  * 部署图用于描述系统**硬件的物理拓扑**结构以及在此结构上运行的软件
  * 部署图可以显示**计算节点的拓扑**结构、**通信**路径、节点上运行的软件、软件包含的逻辑单元（对象、类等）
* 构成部署图的元素主要是 
  * **节点**(node) 
  * **构件**(component)
  * **关系**(relationship)
  * 还可以包含注解、约束、包、子系统
* **节点**
  * 是存在于运行时并代表一项计算资源的的物理元素
    * 通常具有内存和处理能力。如CPU、设备和内存等。
    * 节点可以包含对象和构件实例
  * 用带有节点名称的立方体表示
* 节点和构件的关系
  * 构件（软件）是**参与**系统执行的事物，而节点（服务器）是**执行**构件的事物
  * 构件表示**逻辑元素的物理模块**，而节点表示**构件的物理部署**
* 关系
  * 节点之间的连接，表示节点之间通信的通道，可以使用关联关系的各种修饰（角色，多重性，约束）
* <img src="final_review_UML.assets\image-20220825182359409.png" alt="image-20220825182359409" style="zoom:80%;" />
  <img src="final_review_UML.assets\image-20220825182610677.png" alt="image-20220825182610677" style="zoom: 80%;" />

<img src="final_review_UML.assets\image-20220825184200138.png" alt="image-20220825184200138" style="zoom:80%;" />

# 对象图

* 比较
  * 类图
    * 描述的是系统的静态结构和关系
  * 交互图
    * 顺序图、通信图（旧版UML称为 “协作图”）
    * 描述系统的动态特性
  * **对象图**
    * 描述在某一个时间点上一组对象的状态以及它们之间的关系
    * 在跟踪系统的交互过程时，往往会涉及到系统交互过程的**某一瞬间**交互对象的状态，或者对象**属性的取值**
    * <img src="final_review_UML.assets\image-20220825194204113.png" alt="image-20220825194204113" style="zoom:80%;" />
* 对象图与通信图
  * 同
    * 都是**对象之间的组织关系**，都用到了连接（Link）
  * 异
    * 通信图是**动态图**，反映对象之间的**交互**，**消息标签**依附于连接
    * 对象图是**静态图**，反映某一瞬间，每个对象的**属性取值**（状态）
    * 对象图可以看作通信图在某一瞬间的**快照**
* 对象图组成
  * 对象
    * 如果要可视实例背后的类也可以
  * 链接Link
    * 代表对象之间的连接关系
  * 注解
  * 约束
  * 其他模型包、子系统

<img src="final_review_UML.assets\image-20220825194735033.png" alt="image-20220825194735033" style="zoom:80%;" />![image-20220825194805737](final_review_UML.assets\image-20220825194805737.png)


# 提醒

* 类图中没有关系、类单独存在
* 顺序图中对象符号没有下划线、没有冒号
* 通信图中对象符号，现有对象之间的连接（Link），然后才有依附在Link之上的消息标签， 带序号！